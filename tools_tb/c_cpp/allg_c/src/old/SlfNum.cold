#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "SlfNum.h"
#include "string.h"


static char     SlfNumErrMess[BUFSIZ];
static status_t SlfNumStatus = 0;
char *pSlfNumErrMess = SlfNumErrMess;

/*===========================================================*/
status_t SlfNumInterp1D(uint8 iflag
                       ,double *x   
                       ,double *y
                       ,uint32 nxy
                       ,double x0
                       ,double *y0
                       ,uint32 *piact
                       ,uint8  iord
                       ,uint8  iabl)
{
  double dx=0.0,fak=0.0;
  uint32 i,i0=*piact;
  
  if( nxy == 1 ) {

      if( iabl )
          *y0 = 0.0;
      else
          *y0 = y[0];

      *piact =0;
      return OKAY;

  } else {

#ifdef SLS_NUM_PROOF_FUNCTION
      if(iflag == 1) /* Initialisierung */
      {
        for(i=0;i<nxy-1;i++)
        {
            if( (x[i+1]-x[i]) < (double)EPSILON ) {

                sprintf(SlfNumErrMess,"Error SlfNumInterp1D: x-vector is not monoton increasing !!!");
                SlfNumStatus = NOT_OKAY;
                return NOT_OKAY;
            }
        }
      }
#endif  
      /* Berechnung */
  
      if( i0 > nxy-1 || i0 < 0 ) i0 = 0;
  
      if( x0 >= x[nxy-1] )
      {
         i0 = nxy-1;
         dx  = x0 - x[nxy-1];
         fak = (y[nxy-1]-y[nxy-2])/(x[nxy-1]-x[nxy-2]);
      }
      else if( x0 >= x[i0] )
      {
        for(i=i0;i<=nxy-2;i++)
          if( x0 < x[i+1] )
          {
            i0 = i;
            dx  = x0-x[i];
            fak = (y[i+1]-y[i])/(x[i+1]-x[i]);
            break;
          }  
        
      }
      else if( x0 < x[0] )
      {
        i0 = 0;
        dx  = x0 - x[0];
        fak = (y[1]-y[0])/(x[1]-x[0]);
      }
      else
      {
        for(i=i0-1;i>=0 && i<i0;i--)
          if( x0 >= x[i] )
          {
            i0 = i;
            dx  = x0 - x[i];
            fak = (y[i+1]-y[i])/(x[i+1]-x[i]);
            break;
          }
      }
  
      if( iord == 1 )
      {
        if( iabl == 0 )
          *y0 = y[i0]+fak*dx;
        else
          *y0 = fak;
      }
      else
      {
        if( iabl == 0 )
          *y0 = y[i0];
        else
          *y0 = 0.0f;
      }
   
      *piact = i0;
      return OKAY;
  }
}
/*==============================================================*/
void SlfNumInterp2D_search_index(size_t *piLeft, size_t *piRght,
                                 double u,double *pData,size_t nu)
{
  /* Find the location of current input value in the data table. */
  *piLeft = 0;
  *piRght = nu-1;

  if ( u <= pData[0] )
  {
    /* Less than or equal to the smallest point in the table. */
    *piRght = 0;
  }
  else if ( u >= pData[nu-1] )
  {
    /* Greater than or equal to the largest point in the table. */
    *piLeft = nu-1;
  }
  else
  {
    size_t i;

    /* Do a binary search. */
    while ( ( *piRght - *piLeft ) > 1 )
    {
      /* Get the average of the left and right indices using to Floor rounding. */
      i = (*piLeft + *piRght) >> 1;

      /* Move either the right index or the left index so that */
      /*  LeftDataPoint <= CurrentValue < RightDataPoint */
      if ( u < pData[i] )
      {
        *piRght = i;
      }
      else
      {
        *piLeft = i;
      }
    }
  }
}
/*==============================================================*/
int SlfNumInterp2D(uint8 iflag,double *xvec,size_t nx,double *yvec,size_t ny,
                  Matrix zmat,double x0,double y0,double *z0)
/*******************************************************************
*
*       Interpolation z(nrow,ncol)=f(x(nrow),y(ncol))
*       Der Endwert wird begrenzt
*       iflag           Inittialisierung 0/1
*       xvec[nx]        x-Vektor, monoton steigend
*       yvec[ny]        y-Vektor, monoton steigend
*       zmat[ny][nx]    z-Matrix
*       x0              x-Wert an dem z-Wert bestimmt wird
*       y0              y-Wert an dem z-Wert bestimmt wird
*       z0              z-Wert, der zurÏckgegeben wird
*       init            = 1 Überprüft nur Vektorlänge und Änderung von Punkt zu Punkt
*       return 0        okay
*       return 1        Fehler zuwenig Werte
*       return 2        Fehler nicht monoton steigend
*       return 3        Länge zmat ist kleiner als xvec oder yvec
********************************************************************/
{
    size_t i;
    size_t index_x1,index_x2,index_y1,index_y2;
    double ztemp1,ztemp2;
    double colLambda;
    double rowLambda;
    double ztemp;
    double num;
    double den;

    if( iflag ) {

        if( nx < 1 || ny < 1 )
            return 1;
        if( GET_NROWS(zmat) < ny || GET_NCOLS(zmat) < nx)
            return 3;
        for(i=1;i<nx;i++) {

            if( xvec[i]-xvec[i-1] <= (double)EPSILON )
                return 2;
        }
        for(i=1;i<ny;i++) {

            if( yvec[i]-yvec[i-1] <= (double)EPSILON )
                return 2;
        }
        return 0;
    }

    SlfNumInterp2D_search_index(&index_x1,&index_x2,x0,xvec,nx);
    SlfNumInterp2D_search_index(&index_y1,&index_y2,y0,yvec,ny);

    if ( yvec[index_y1] != yvec[index_y2] )
    {
      den = yvec[index_y2];
      den -= yvec[index_y1];
      num = y0;
      num -= yvec[index_y1];
      {
        colLambda = (num/den);
      }
    }
    else
    {
      colLambda = 0;
    }
    if ( xvec[index_x1] != xvec[index_x2] )
    {

      den = xvec[index_x2];
      den -= xvec[index_x1];
      num = x0;
      num -= xvec[index_x1];
      {
        rowLambda = (num/den);
      }
    }
    else
    {
      rowLambda = 0;
    }
    /* Interpolate along column variable
     *    with the row variable locked on the left row
     */
      ztemp1 = zmat[index_y1][index_x1];
      ztemp  = zmat[index_y2][index_x1];
      ztemp1 += colLambda * ( ztemp - ztemp1 );
    /* Interpolate along column variable
     *    with the row variable locked on the right row
     */
      ztemp2 = zmat[index_y1][index_x2];
      ztemp  = zmat[index_y2][index_x2];
      ztemp2 += colLambda * ( ztemp - ztemp2 );
    /*
     * Interpolate along row variable
     *    with the col variable locked on its interpolated value
     */
      ztemp1 += rowLambda * ( ztemp2 - ztemp1 );
      *z0 = ztemp1;
  
    

    return 0;
  
}
/*==============================================================*/
void SlfNumStepSet(SSlfNumStep *s,double xa,double xb,double ya,double yb) {

    s->xa = MIN(xa,xb);
    s->xb = MAX(xa,xb);
    s->dx = MAX(EPSILON,ABS(xb-xa));
    s->ya = ya;
    s->yb = yb;
    s->dy = yb-ya;
}
void SlfNumStepCalc(SSlfNumStep *s,double x) {

    double xx = (x-s->xa)/s->dx;

    s->x  = x;

    if( x <= s->xa ) {

        s->y  = s->ya;
        s->yp = 0.0;
    } else if( x >= s->xb ) {

        s->y  = s->yb;
        s->yp = 0.0;
    } else {
        s->y  = 3. - 2. * xx;
        s->y  = s->ya + s->dy * xx * xx * s->y;

        s->yp = 1. - xx;
        s->yp = 6. * s->dy / s->dx * xx * s->yp;
    }
}
/*===========================================================*/
double SlfNumATan2(double y,double x)
{
    double dum;
    if( x < 1.e-30 && x > -1.e-30 )
    {
      if( y < 1.e-30 && y > -1.e-30 )
        return 0.0f;
      else if(y > 0.)
        return((PI/(double)2.));
      else
        return(-(PI/(double)2.));
    }
    else if( x > 0. )
    {
      dum = y/x;
      return atan(dum);
/*      return(dum*(1+dum*dum*(-0.33333+dum*dum/5.))); */
    }
    else
    {
      dum = y/x;
      if( y >= 0. )
      {
        return PI+atan(dum);
/*        return(PI+dum*(1+dum*dum*(-0.33333+dum*dum/5.))); */
      }
      else
      {
        return -PI+atan(dum);
/*        return(-PI+dum*(1+dum*dum*(-0.33333+dum*dum/5.))); */
      }
    }
}
//===============================================
//  m = sqrt(a^2+b^2)
//===============================================
double SlfNumSqrt2(double a, double b) {
    return sqrt(a*a+b*b);
}
/***********************************************************************

matrix.c - simple matrix operations

Copyright (C) 1991 Dean Rubine

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License. See ../COPYING for
the full agreement.
**********************************************************************/

//=================================================================
//=================================================================
// Build/Destroy Vector/Matrix
//=================================================================
//=================================================================
Vector NewVector(uarray r)
{
	register struct array_header *a;
	register Vector v;

	a = (struct array_header *)
	    SlfNumAllocate(sizeof(struct array_header) + r * sizeof(double), char);

	a->ndims = 1;
	a->nrows = r;
	a->ncols = 1;
    a->link  = 0;
	v = (Vector) (a + 1);

#ifdef SLS_NUM_PROOF_FUNCTION

	if(HEADER(v) != (struct array_header *) a ||
	   GET_NDIMS(v) != 1 || GET_NROWS(v) != r || GET_NCOLS(v) != 1) {
	    	sprintf(SlfNumErrMess,"NewRowVector error: v=%x H: %x,%x  D:%d,%d  R:%d,%d  C:%d,%d\n", v,  HEADER(v), a,  GET_NDIMS(v), 1,  GET_NROWS(v), r, GET_NCOLS(v), 1);
            SlfNumStatus = NOT_OKAY;
            return NULL;
	    }
#endif

	return v;
}
Matrix NewMatrix(uarray r,uarray c)
{
	register struct array_header *a = (struct array_header *)
	   SlfNumAllocate(sizeof(struct array_header) + r * sizeof(double *), char);
	register uarray i;
	register Matrix m;

	m = (Matrix) (a + 1);
	for(i = 0; i < r; i++)
		m[i] = SlfNumAllocate(c, double);
	a->ndims = 2;
	a->nrows = r;
	a->ncols = c;
    a->link  = 0;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(HEADER(m) != (struct array_header *) a ||
	   GET_NDIMS(m) != 2 || GET_NROWS(m) != r || GET_NCOLS(m) != c) {
	    	sprintf(SlfNumErrMess,"NewCollVector error: v=%x H: %x,%x  D:%d,%d  R:%d,%d  C:%d,%d\n", m,  HEADER(m), a,  GET_NDIMS(m), 2,  GET_NROWS(m), r, GET_NCOLS(m), c);
            SlfNumStatus = NOT_OKAY;
            return NULL;
	    }
#endif

    return m;
}
//=====================================================
// Es wird bestehender Vektor, der als Matrix benutzt wird
// auf die Matrix-Struktur gelinkt, es wird nur noch Speicher 
// double ** allokiert
//=====================================================
Matrix  LinkMatrix(double *pVec,uarray r,uarray c){
	
    register struct array_header *a = (struct array_header *)
	   SlfNumAllocate(sizeof(struct array_header) + r * sizeof(double *), char);
	register uarray i;
	register Matrix m;

	m = (Matrix) (a + 1);
	for(i = 0; i < r; i++)
		m[i] = pVec+i*c;

	a->ndims = 2;
	a->nrows = r;
	a->ncols = c;
    a->link  = 1; // Zeigt an, dass pVec auf m gelinkt ist

#ifdef SLS_NUM_PROOF_FUNCTION
	if(HEADER(m) != (struct array_header *) a ||
	   GET_NDIMS(m) != 2 || GET_NROWS(m) != r || GET_NCOLS(m) != c) {
	    	sprintf(SlfNumErrMess,"NewCollVector error: v=%x H: %x,%x  D:%d,%d  R:%d,%d  C:%d,%d\n", m,  HEADER(m), a,  GET_NDIMS(m), 2,  GET_NROWS(m), r, GET_NCOLS(m), c);
            SlfNumStatus = NOT_OKAY;
            return NULL;
	    }
#endif

    return m;
}

Vector VectorCopyD(double *pdval,uarray r)
{
	register struct array_header *a;
	register Vector v;

	a = (struct array_header *)
	    SlfNumAllocate(sizeof(struct array_header) + r * sizeof(double), char);

	a->ndims = 1;
	a->nrows = r;
	a->ncols = 1;
    a->link  = 0;
	v = (Vector) (a + 1);

	memcpy(v,pdval,sizeof(double)*r);

#ifdef SLS_NUM_PROOF_FUNCTION

	if(HEADER(v) != (struct array_header *) a ||
	   GET_NDIMS(v) != 1 || GET_NROWS(v) != r || GET_NCOLS(v) != 1) {
	    	sprintf(SlfNumErrMess,"NewRowVector error: v=%x H: %x,%x  D:%d,%d  R:%d,%d  C:%d,%d\n", v,  HEADER(v), a,  GET_NDIMS(v), 1,  GET_NROWS(v), r, GET_NCOLS(v), 1);
            SlfNumStatus = NOT_OKAY;
            return NULL;
	    }
#endif

	return v;
}
Matrix MatrixCopyD(double *pdval,uarray r,uarray c,uint8 type)
{
	register struct array_header *a = (struct array_header *)
	   SlfNumAllocate(sizeof(struct array_header) + r * sizeof(double *), char);
	register uarray i,j;
	register Matrix m;

	m = (Matrix) (a + 1);
	for(i = 0; i < r; i++)
		m[i] = SlfNumAllocate(c, double);
	a->ndims = 2;
	a->nrows = r;
	a->ncols = c;
    a->link  = 0;

	if( type == DOUBLE_MATRIX_ROW_BEFORE_COL ) {

		for(i = 0; i < r; i++)
			for(j = 0; j < c; j++)
				m[i][j] = pdval[i+j*r];
	} else {
		for(i = 0; i < r; i++)
			for(j = 0; j < c; j++)
				m[i][j] = pdval[i*c+j];
	}
#ifdef SLS_NUM_PROOF_FUNCTION
	if(HEADER(m) != (struct array_header *) a ||
	   GET_NDIMS(m) != 2 || GET_NROWS(m) != r || GET_NCOLS(m) != c) {
	    	sprintf(SlfNumErrMess,"NewCollVector error: v=%x H: %x,%x  D:%d,%d  R:%d,%d  C:%d,%d\n", m,  HEADER(m), a,  GET_NDIMS(m), 2,  GET_NROWS(m), r, GET_NCOLS(m), c);
            SlfNumStatus = NOT_OKAY;
            return NULL;
	    }
#endif

    return m;
}
void FreeVector(Vector v)
{
	free(HEADER(v));
}
void FreeMatrix(Matrix m)
{
	register uarray i;

	if( !ISLINKED(m) ) {
	    for(i = 0; i < GET_NROWS(m); i++)
		    free(m[i]);
    }
	free(HEADER(m));
}

Vector VectorCopy(register Vector v)
{
	register Vector r = NewVector(GET_NROWS(v));
	register uarray i;

	for(i = 0; i < GET_NROWS(v); i++)
		r[i] = v[i];
	return r;
}
Matrix MatrixCopy(register Matrix m)
{
	register Matrix r = NewMatrix(GET_NROWS(m), GET_NCOLS(m));
	register uarray i, j;

	for(i = 0; i < GET_NROWS(m); i++)
		for(j = 0; j < GET_NROWS(m); j++)
			r[i][j] = m[i][j];
	return r;
}

//=================================================================
//=================================================================
// Vector/Matrix Calculaton
//=================================================================
//=================================================================
void ZeroVector(Vector v)
{
	register uarray i;
	for(i = 0; i < GET_NROWS(v); i++) v[i] = 0.0;
}


void ZeroMatrix(Matrix m)
{
	register uarray i, j;
	for(i = 0; i < GET_NROWS(m); i++)
		for(j = 0; j < GET_NCOLS(m); j++)
			m[i][j] = 0.0;
}

void FillMatrix(Matrix m,double fill)
{
	register uarray i, j;
	for(i = 0; i < GET_NROWS(m); i++)
		for(j = 0; j < GET_NCOLS(m); j++)
			m[i][j] = fill;
}
double InnerProduct(register Vector v1,register Vector  v2)
{
	double result = 0;
	uarray i;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(v1) != GET_NROWS(v2)) {
		sprintf(SlfNumErrMess,"InnerProduct %d x %d ", GET_NROWS(v1), GET_NROWS(v2));
        SlfNumStatus = NOT_OKAY;
        return 0.0;
	    }
#endif
	
    for(i = 0; i < GET_NROWS(v1); i++)
        result += v1[i] * v2[i];
	return result;
}
/*
Compute result = m1*m2 where
	m1 is a matrix (r1 x c1)
	m2 is a matrix (r2 x c2)
	result is a matrix (r1 x c2)
=================================================================================
=================================================================================
*/
void MatrixMultiply(register Matrix m1,register Matrix  m2,register Matrix  result)
{
	register uarray i, j, k;
	double sum;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NCOLS(m1) != GET_NROWS(m2)) {
		sprintf(SlfNumErrMess,"MatrixMultiply: Can't multiply %dx%d and %dx%d matrices",
			GET_NROWS(m1), GET_NCOLS(m1), GET_NROWS(m2), GET_NCOLS(m2));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
	if(GET_NROWS(result) != GET_NROWS(m1) || GET_NCOLS(result) != GET_NCOLS(m2)) {
		sprintf(SlfNumErrMess,"MatrixMultiply: %dx%d times %dx%d does not give %dx%d product",
			GET_NROWS(m1), GET_NCOLS(m1), GET_NROWS(m2), GET_NCOLS(m2),
			GET_NROWS(result), GET_NCOLS(result));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif
	for(i = 0; i < GET_NROWS(m1); i++)
		for(j = 0; j < GET_NCOLS(m2); j++) {
			sum = 0;
			for(k = 0; k < GET_NCOLS(m1); k++)
				sum += m1[i][k] * m2[k][j];
			result[i][j] = sum;
		}
}
/*
Compute vres = m * v where
	v is a row vector (rv x 1) 
	m is a matrix (r x c)
	vres is a row vector (r x 1) 
*/
void MatrixTimesVector(Matrix m,Vector v,Vector vres)
{
	register uarray i, j;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(v) != GET_NCOLS(m)) {
		sprintf(SlfNumErrMess,"MatrixTimesVector: %dx%d mat time %d vector does not fit",
			GET_NROWS(m), GET_NCOLS(m), GET_NROWS(v));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
	if(GET_NROWS(vres) != GET_NROWS(m)) {
		sprintf(SlfNumErrMess,"MatrixTimesVector: %d res-vector = %dx%d mat time %d vector does not fit",
			GET_NROWS(vres),GET_NROWS(m), GET_NCOLS(m), GET_NROWS(v));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif
	for(i = 0; i < GET_NROWS(m); i++) {
		vres[i] = 0;
		for(j = 0; j < GET_NCOLS(m); j++)
			vres[i] += v[j] * m[i][j];
	}
}	
/*
Compute vres' = v' * m where
	v is a row vector (r x 1) (v' column vector)
	m is a matrix (r x c)
	vres' is a column vector (c x 1) (vres row vector)
*/
void VectorTimesMatrix(Vector v,Matrix m,Vector vres)
{
	register uarray i, j;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(v) != GET_NROWS(m)) {
		sprintf(SlfNumErrMess,"VectorTimesMatrix: Can't multiply %d vector by %dx%d",
			GET_NROWS(v), GET_NROWS(m), GET_NCOLS(m));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
	if(GET_NROWS(vres) != GET_NCOLS(m)) {
		sprintf(SlfNumErrMess,"VectorTimesMatrix: %d vector times %dx%d mat does not fit in %d product" ,
			GET_NROWS(v), GET_NROWS(m), GET_NCOLS(m), GET_NROWS(vres));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif
	for(j = 0; j < GET_NCOLS(m); j++) {
		vres[j] = 0;
		for(i = 0; i < GET_NROWS(m); i++)
			vres[j] += v[i] * m[i][j];
	}
}	
void ScalarTimesVector(double s,Vector v,Vector vres)
{
	register uarray i;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(v) != GET_NROWS(vres)) {
		sprintf(SlfNumErrMess,"ScalarTimesVector: result wrong size (%d!=%d)",
			GET_NROWS(v), GET_NROWS(vres));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif
	for(i = 0; i < GET_NROWS(v); i++)
        vres[i] = s * v[i];
}

void ScalarTimesMatrix(double s,Matrix m,Matrix mres)
{
	register uarray i, j;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(m) != GET_NROWS(mres)  || 
	   GET_NCOLS(m) != GET_NCOLS(mres)) {
		sprintf(SlfNumErrMess,"ScalarTimesMatrix: result wrong size (%d!=%d)or(%d!=%d)",
			GET_NROWS(m), GET_NROWS(mres),
			GET_NCOLS(m), GET_NCOLS(mres));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif

	for(i = 0; i < GET_NROWS(m); i++)
		for(j = 0; j < GET_NCOLS(m); j++)
			mres[i][j] = s * m[i][j];
}
/*
 Compute v'mv
 */

double QuadraticForm(register Vector v,register Matrix  m)
{
	register uarray i, j, n;
	double result = 0;

	n = GET_NROWS(v);

#ifdef SLS_NUM_PROOF_FUNCTION
	if(n != GET_NROWS(m) || n != GET_NCOLS(m)) {
		sprintf(SlfNumErrMess,"QuadraticForm: bad matrix size (%dx%d not %dx%d)",
			GET_NROWS(m), GET_NCOLS(m), n, n);
        SlfNumStatus = NOT_OKAY;
        return 0;
	    }
#endif
	for(i = 0; i < n; i++)
		for(j = 0; j < n; j++) {

#ifdef PIQ_DEBUG
			printf("%g*%g*%g [%g] %s ",
			m[i][j],v[i],v[j],
			m[i][j] * v[i] * v[j],
			i==n-1&&j==n-1? "=" : "+");
#endif

			result += m[i][j] * v[i] * v[j];
		}
	return result;
}
/* Matrix inversion using full pivoting.
 * The standard Gauss-Jordan method is used.
 * The return value is the determinant.
 * The input matrix may be the same as the result matrix
 *
 *	det = InvertMatrix(inputmatrix, resultmatrix);
 *
 * HISTORY
 * 26-Feb-82  David Smith (drs) at Carnegie-Mellon University
 *	Written.
 * Sun Mar 20 19:36:16 EST 1988 - converted to this form by Dean Rubine
 *
 */
int	DebugInvertMatrix = 0;

#define PERMBUFSIZE 200	/* Max mat size */

double InvertMatrix(Matrix ym,Matrix rm)
{
	register uarray i, j, k;
	double det, biga, recip_biga, hold;
	iarray l[PERMBUFSIZE], m[PERMBUFSIZE];
	register uarray n;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(ym) != GET_NCOLS(ym)) {
		sprintf(SlfNumErrMess,"InvertMatrix: not square");
        SlfNumStatus = NOT_OKAY;
        return 0;
	    }
#endif

	n = GET_NROWS(ym);

#ifdef SLS_NUM_PROOF_FUNCTION
	if(n != GET_NROWS(rm) || n != GET_NCOLS(rm)) {
		sprintf(SlfNumErrMess,"InvertMatrix: result wrong size");
        SlfNumStatus = NOT_OKAY;
        return 0;
	    }
#endif

	/* Copy ym to rm */
	
	if(ym != rm)
		for(i = 0; i < n; i++)
			for(j = 0; j < n; j++)
				rm[i][j] = ym[i][j];

	/*if(DebugInvertMatrix) PrintMatrix(rm, "Inverting (det=%g)\n", det);*/

    /* Allocate permutation vectors for l and m, with the same origin
       as the matrix. */

#ifdef SLS_NUM_PROOF_FUNCTION
	if (n >= PERMBUFSIZE) {
		sprintf(SlfNumErrMess,"InvertMatrix: PERMBUFSIZE");
        SlfNumStatus = NOT_OKAY;
        return 0;
	}
#endif

	det = 1.0;
	for (k = 0; k < n;  k++) {
		l[k] = k;  m[k] = k;
		biga = rm[k][k];

		/* Find the biggest element in the submatrix */
		for (i = k;  i < n;  i++)
			for (j = k; j < n; j++)
				if (ABS(rm[i][j]) > ABS(biga)) {
					biga = rm[i][j];
					l[k] = i;
					m[k] = j;
				}

//		if(DebugInvertMatrix) 
//			if(biga == 0.0)
//				PrintMatrix(m, "found zero biga = %g\n", biga);

		/* Interchange rows */
		i = l[k];
		if (i > k)
			for (j = 0; j < n; j++) {
				hold = -rm[k][j];
				rm[k][j] = rm[i][j];
				rm[i][j] = hold;
			}

		/* Interchange columns */
		j = m[k];
		if (j > k)
			for (i = 0; i < n; i++) {
				hold = -rm[i][k];
				rm[i][k] = rm[i][j];
				rm[i][j] = hold;
			}

		/* Divide column by minus pivot
		    (value of pivot element is contained in biga). */
		if (biga == 0.0) {
			return 0.0;
		}

		if(DebugInvertMatrix) printf("biga = %g\n", biga);
		recip_biga = 1/biga;
		for (i = 0; i < n; i++)
			if (i != k)
				rm[i][k] *= -recip_biga;

		/* Reduce matrix */
		for (i = 0; i < n; i++)
			if (i != k) {
				hold = rm[i][k];
				for (j = 0; j < n; j++)
					if (j != k)
						rm[i][j] += hold * rm[k][j];
			}

		/* Divide row by pivot */
		for (j = 0; j < n; j++)
			if (j != k)
				rm[k][j] *= recip_biga;

		det *= biga;	/* Product of pivots */
		if(DebugInvertMatrix) printf("det = %g\n", det);
		rm[k][k] = recip_biga;

	}	/* K loop */

	/* Final row & column interchanges */
	for (k = n - 1; k >= 0 && k<n; k--) {
		i = l[k];
		if (i > k)
			for (j = 0; j < n; j++) {
				hold = rm[j][k];
				rm[j][k] = -rm[j][i];
				rm[j][i] = hold;
			}
		j = m[k];
		if (j > k)
			for (i = 0; i < n; i++) {
				hold = rm[k][i];
				rm[k][i] = -rm[j][i];
				rm[j][i] = hold;
			}
	}

	if(DebugInvertMatrix) printf("returning, det = %g\n", det);

	return det;
}

void VectorAdd(Vector va,Vector vb, Vector vres)
{
	register uarray i;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(va) != GET_NROWS(vb)) {
		sprintf(SlfNumErrMess,"VectorAdd: result wrong size (dim(va)=%d !=dim(vb)=%d )",
			GET_NROWS(va), GET_NROWS(vb));
        SlfNumStatus = NOT_OKAY;
		return;
    }
	if(GET_NROWS(va) != GET_NROWS(vres)) {
		sprintf(SlfNumErrMess,"VectorAdd: result wrong size (dim(va)=%d !=dim(vres)=%d )",
			GET_NROWS(va), GET_NROWS(vres));
        SlfNumStatus = NOT_OKAY;
		return;
    }
#endif
	for(i=0;i<GET_NROWS(va);i++) 
		vres[i] = va[i] + vb[i];
}
// vres = v + s
void VectorAddScalar(double s,Vector v,Vector vres)
{
	register uarray i;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(v) != GET_NROWS(vres)) {
		sprintf(SlfNumErrMess,"VectorAddScalar: result wrong size (%d!=%d)",
			GET_NROWS(v), GET_NROWS(vres));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif
	for(i = 0; i < GET_NROWS(v); i++)
        vres[i] =  v[i]+s;
}
// mres = ma + s;
void MatrixAddScalar(double s,Matrix ma, Matrix mres) {

	register uarray i,j;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(  GET_NROWS(mres) != GET_NROWS(ma)
      || GET_NCOLS(mres) != GET_NCOLS(ma)) {
		sprintf(SlfNumErrMess,"MatrixAddScalar: result wrong size (dim(mres)=(%dx%d) !=dim(ma)=(%dx%d) )",
			GET_NROWS(mres),GET_NCOLS(mres), GET_NROWS(ma),GET_NCOLS(ma));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif
	for(i=0;i<GET_NROWS(mres);i++) 
    	for(j=0;j<GET_NCOLS(mres);j++) 
		    mres[i][j] = ma[i][j] + s;
} 

// vres = va - vb
//===============
void VectorSub(Vector va,Vector vb, Vector vres)
{
	register uarray i;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(va) != GET_NROWS(vb)) {
		sprintf(SlfNumErrMess,"VectorSub: result wrong size (dim(va)=%d !=dim(vb)=%d )",
			GET_NROWS(va), GET_NROWS(vb));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
	if(GET_NROWS(va) != GET_NROWS(vres)) {
		sprintf(SlfNumErrMess,"VectorSub: result wrong size (dim(va)=%d !=dim(vres)=%d )",
			GET_NROWS(va), GET_NROWS(vres));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif
	for(i=0;i<GET_NROWS(va);i++) 
		vres[i] = va[i] - vb[i];
}
// vio = vio + s*vadd
//===================
void VectorMultAdd(double s,Vector vadd, Vector vio) {

	register uarray i;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(vio) != GET_NROWS(vadd)) {
		sprintf(SlfNumErrMess,"VectorMultAdd: result wrong size (dim(vio)=%d !=dim(vadd)=%d )",
			GET_NROWS(vio), GET_NROWS(vadd));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif
	for(i=0;i<GET_NROWS(vadd);i++) 
		vio[i] = vio[i] + s*vadd[i];
}
// vio = vio - s*vsub
//===================
void VectorMultSub(double s,Vector vsub, Vector vio) {

	register uarray i;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(vio) != GET_NROWS(vsub)) {
		sprintf(SlfNumErrMess,"VectorMultSub: result wrong size (dim(vio)=%d !=dim(vsub)=%d )",
			GET_NROWS(vio), GET_NROWS(vsub));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif
	for(i=0;i<GET_NROWS(vsub);i++) 
		vio[i] = vio[i] - s*vsub[i];
}
// mio = mio + s*madd;
void MatrixMultAdd(double s,Matrix madd, Matrix mio) {

	register uarray i,j;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(  GET_NROWS(mio) != GET_NROWS(madd)
      || GET_NCOLS(mio) != GET_NCOLS(madd)) {
		sprintf(SlfNumErrMess,"MatrixMultAdd: result wrong size (dim(mio)=(%dx%d) !=dim(madd)=(%dx%d) )",
			GET_NROWS(mio),GET_NCOLS(mio), GET_NROWS(madd),GET_NCOLS(madd));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif
	for(i=0;i<GET_NROWS(mio);i++) 
    	for(j=0;j<GET_NCOLS(mio);j++) 
		    mio[i][j] = mio[i][j] + s*madd[i][j];
}
// mio = mio - s*msub;
void MatrixMultSub(double s,Matrix msub, Matrix mio) {

	register uarray i,j;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(  GET_NROWS(mio) != GET_NROWS(msub)
      || GET_NCOLS(mio) != GET_NCOLS(msub)) {
		sprintf(SlfNumErrMess,"MatrixMultSub: result wrong size (dim(mio)=(%dx%d) !=dim(madd)=(%dx%d) )",
			GET_NROWS(mio),GET_NCOLS(mio), GET_NROWS(msub),GET_NCOLS(msub));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif
	for(i=0;i<GET_NROWS(mio);i++) 
    	for(j=0;j<GET_NCOLS(mio);j++) 
		    mio[i][j] = mio[i][j] - s*msub[i][j];
} 

void VectorDivideScalar(double s,Vector v,Vector vres)
{
	register uarray i;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(v) != GET_NROWS(vres)) {
		sprintf(SlfNumErrMess,"ScalarTimesVector: result wrong size (%d!=%d)",
			GET_NROWS(v), GET_NROWS(vres));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif
	for(i = 0; i < GET_NROWS(v); i++)
        vres[i] = v[i]/s;
}

double VectorNorm(Vector v) {

    return sqrt(InnerProduct(v,v));
}
void VectorAbs(Vector v) {
	register uarray i;

	for(i = 0; i < GET_NROWS(v); i++)
        v[i] = fabs(v[i]);
}

void UnifyVector(Vector v, Vector e) {

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(v) != GET_NROWS(e)) {
		sprintf(SlfNumErrMess,"UnifyVector: result wrong size v(%d) != e(%d)",
			GET_NROWS(v), GET_NROWS(e));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif

    VectorDivideScalar(NOT_ZERO(VectorNorm(v)),v,e);
}

void MakeTildeMatrix(Vector v,Matrix mres) {

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(v) != 3  ) {
		sprintf(SlfNumErrMess,"MakeTildeMatrix: Vektorwrong size v(%d) != 3",
			GET_NROWS(v));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
	if(GET_NROWS(mres) != 3  || 
	   GET_NCOLS(mres) != 3) {
		sprintf(SlfNumErrMess,"MakeTildeMatrix: result wrong size mres(%d,%d) != 3x3",
			GET_NROWS(mres),
			GET_NCOLS(mres));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif

    mres[0][0] = 0.0;
    mres[1][0] = v[2];
    mres[2][0] = -v[1];

    mres[0][1] = -v[2];
    mres[1][1] = 0.0;
    mres[2][1] = v[0];

    mres[0][2] = v[1];
    mres[1][2] = -v[0];
    mres[2][2] = 0.0;

}
//
// M= rtilde' * rtilde
void MakeTransponeTildeMatrixMultTildeMatrix(Vector v,Matrix mres) {

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(v) != 3  ) {
		sprintf(SlfNumErrMess,"MakeTransponeTildeMatrixMultTildeMatrix: Vektorwrong size v(%d) != 3",
			GET_NROWS(v));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
	if(GET_NROWS(mres) != 3  || 
	   GET_NCOLS(mres) != 3) {
		sprintf(SlfNumErrMess,"MakeTransponeTildeMatrixMultTildeMatrix: result wrong size mres(%d,%d) != 3x3",
			GET_NROWS(mres),
			GET_NCOLS(mres));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif

    mres[0][0] = v[1]*v[1]+v[2]+v[2];
    mres[1][0] = -v[0]*v[1];
    mres[2][0] = -v[0]*v[2];

    mres[0][1] = mres[1][0];
    mres[1][1] = v[0]*v[0]+v[2]+v[2];
    mres[2][1] = -v[1]*v[2];

    mres[0][2] = mres[2][0];
    mres[1][2] = mres[2][1];
    mres[2][2] = v[0]*v[0]+v[1]*v[1];

}
// mres = v*v'
//============
void MakeVectorMultTransponeVektor(Vector va,Vector vtotrans, Matrix mres) {

    uarray i,j;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(va) != GET_NROWS(mres) || GET_NROWS(vtotrans) != GET_NCOLS(mres)) {
		sprintf(SlfNumErrMess,"MakeVectorMultTransponeVektor: result wrong size");
        SlfNumStatus = NOT_OKAY;
        return;
	    }
#endif

    for(i=0;i<GET_NROWS(va);i++)
        for(j=0;j<GET_NROWS(vtotrans);j++)
            mres[i][j] = va[i]*vtotrans[j];
}
void MatrixAdd(Matrix ma,Matrix mb,Matrix mres) {

	register uarray i, j;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(ma) != GET_NROWS(mres)  || 
	   GET_NCOLS(ma) != GET_NCOLS(mres)) {
		sprintf(SlfNumErrMess,"MatrixAdd: result wrong size ma(%d x %d) != mres(%d x %d)",
			GET_NROWS(ma), GET_NCOLS(ma),
			GET_NROWS(mres), GET_NCOLS(mres));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
	if(GET_NROWS(mb) != GET_NROWS(mres)  || 
	   GET_NCOLS(mb) != GET_NCOLS(mres)) {
		sprintf(SlfNumErrMess,"MatrixAdd: result wrong size ma(%d x %d) != mres(%d x %d)",
			GET_NROWS(mb), GET_NCOLS(mb),
			GET_NROWS(mres), GET_NCOLS(mres));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif

	for(i = 0; i < GET_NROWS(mres); i++)
		for(j = 0; j < GET_NCOLS(mres); j++)
			mres[i][j] = ma[i][j] + mb[i][j];
}
// mres = ma - mb
//===============
void MatrixSub(Matrix ma,Matrix mb,Matrix mres) {

	register uarray i, j;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(ma) != GET_NROWS(mres)  || 
	   GET_NCOLS(ma) != GET_NCOLS(mres)) {
		sprintf(SlfNumErrMess,"MatrixSub: result wrong size ma(%d x %d) != mres(%d x %d)",
			GET_NROWS(ma), GET_NCOLS(ma),
			GET_NROWS(mres), GET_NCOLS(mres));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
	if(GET_NROWS(mb) != GET_NROWS(mres)  || 
	   GET_NCOLS(mb) != GET_NCOLS(mres)) {
		sprintf(SlfNumErrMess,"MatrixSub: result wrong size ma(%d x %d) != mres(%d x %d)",
			GET_NROWS(mb), GET_NCOLS(mb),
			GET_NROWS(mres), GET_NCOLS(mres));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif

	for(i = 0; i < GET_NROWS(mres); i++)
		for(j = 0; j < GET_NCOLS(mres); j++)
			mres[i][j] = ma[i][j] - mb[i][j];
}
// M[i+irow][j+icol] = m[i][j]
//============================
void PutMatrixToMatrix(Matrix m,Matrix M,uarray irow,uarray icol) {

    uarray i, j;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(irow+GET_NROWS(m) > GET_NROWS(M)  || 
	   icol+GET_NCOLS(m) > GET_NCOLS(M)) {
		sprintf(SlfNumErrMess,"PutMatrixToMatrix: size m(%d x %d) doesn't fit to M(%d x %d) at pos irow=%d,icol=%l",
			GET_NROWS(m), GET_NCOLS(m),
			GET_NROWS(M), GET_NCOLS(M),
            irow,icol);
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif

	for(i = 0; i < GET_NROWS(m); i++)
		for(j = 0; j < GET_NCOLS(m); j++)
			M[irow+i][icol+j] = m[i][j];


}
void PutVectorToMatrix(Vector v, Matrix M, uarray irow, uarray icol) {

    uarray i;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(irow+GET_NROWS(v) > GET_NROWS(M)  || 
	   icol+1 > GET_NCOLS(M)) {
		sprintf(SlfNumErrMess,"PutVectorToMatrix: size v(%d) doesn't fit to M(%d x %d) at pos irow=%d,icol=%l",
			GET_NROWS(v),
			GET_NROWS(M), GET_NCOLS(M),
            irow,icol);
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif

	for(i = 0; i < GET_NROWS(v); i++)
		M[irow+i][icol] = v[i];


}
void PutVectorToVector(Vector v, Vector vres, uarray irow) {

    uarray i;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(irow+GET_NROWS(v) > GET_NROWS(vres) ) {
		sprintf(SlfNumErrMess,"PutVectorxToVector: size v(%d) doesn't fit to vres(%d) at pos irow=%d",
			GET_NROWS(v),
			GET_NROWS(vres),
            irow);
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif

	for(i = 0; i < GET_NROWS(v); i++)
		vres[irow+i] = v[i];
}
void PutVectorToVectorMax(Vector v, Vector vres, uarray nmax) {

    uarray i;
    
    nmax = MIN(GET_NROWS(v),nmax);
    nmax = MIN(GET_NROWS(vres),nmax);


	for(i = 0; i < nmax; i++)
		vres[i] = v[i];
}
void PutMatrixToMatrixMax(Matrix m, Matrix M, uarray nrowmax, uarray ncolmax) {

    uarray i, j;

    nrowmax = MIN(GET_NROWS(m),nrowmax);
    nrowmax = MIN(GET_NROWS(M),nrowmax);
    ncolmax = MIN(GET_NCOLS(m),ncolmax);
    ncolmax = MIN(GET_NCOLS(M),ncolmax);

	for(i = 0; i < nrowmax; i++)
		for(j = 0; j < ncolmax; j++)
			M[i][j] = m[i][j];


}void TransponeMatrix(Matrix m,Matrix mres) {

	register uarray i, j;
    Matrix          mm;

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(m) != GET_NCOLS(mres)  || 
	   GET_NCOLS(m) != GET_NROWS(mres)) {
		sprintf(SlfNumErrMess,"MatrixAdd: result wrong size m(%d x %d) could not be transponed to mres(%d x %d)",
			GET_NROWS(m), GET_NCOLS(m),
			GET_NROWS(mres), GET_NCOLS(mres));
        SlfNumStatus = NOT_OKAY;
		return;
	    }
#endif

    if( m == mres ){

        mm = NewMatrix(GET_NCOLS(m),GET_NROWS(m));

	    for(i = 0; i < GET_NROWS(m); i++)
		    for(j = 0; j < GET_NCOLS(m); j++)
			    mm[j][i] = m[i][j];

	    for(i = 0; i < GET_NROWS(mm); i++)
		    for(j = 0; j < GET_NCOLS(mm); j++)
			    mres[i][j] = mm[i][j];

        FreeMatrix(mm);
    } else {

        for(i = 0; i < GET_NROWS(m); i++)
		    for(j = 0; j < GET_NCOLS(m); j++)
			    mres[j][i] = m[i][j];
    }

}
void VectorCrossProduct(Vector va,Vector vb, Vector vres) {

#ifdef SLS_NUM_PROOF_FUNCTION
	if(GET_NROWS(va) != 3  ) {
		sprintf(SlfNumErrMess,"MakeTildeMatrix: Vektorwrong size v(%d) != 3",
			GET_NROWS(va));
        SlfNumStatus = NOT_OKAY;
		return;
	}
	if(GET_NROWS(vb) != 3  ) {
		sprintf(SlfNumErrMess,"MakeTildeMatrix: Vektorwrong size v(%d) != 3",
			GET_NROWS(va));
        SlfNumStatus = NOT_OKAY;
		return;
	}
	if(GET_NROWS(vres) != 3  ) {
		sprintf(SlfNumErrMess,"MakeTildeMatrix: Vektorwrong size v(%d) != 3",
			GET_NROWS(va));
        SlfNumStatus = NOT_OKAY;
		return;
	}
#endif

    vres[0] = va[1]*vb[2]-va[2]*vb[1];
    vres[1] = va[2]*vb[0]-va[0]*vb[2];
    vres[2] = va[0]*vb[1]-va[1]*vb[0];

}
//=================================================================
//=================================================================
// Memory allocation, Do not call this function directly, 
// use SlfNumAllocate(n, type)
//=================================================================
//=================================================================
void *SlfNumAllocateFunc(uint32 nitems, uint32 itemsize, char *tname)
{
	register uint32 bytes = nitems * itemsize;
	register void *p = malloc(bytes)/*new char[bytes]*/;

#ifdef SLS_NUM_PROOF_FUNCTION
    if(p == NULL) 
       sprintf(SlfNumErrMess,"Error SlfNumAllocatFunc: Can't get mem for %d %s's (each %d bytes, %d total bytes)",
		nitems, tname, itemsize, bytes);
#endif
	return p;
}

//==============================================================================
// LU-Decomposition by Gaussian elimination
// ========================================
// Input
// a[0 ... n-1][0 ... n-1]
// Output
// a[beta11,beta12, ..., beta1n;
//   alph21,beta22, ..., beta2n;
//   alph31,alph32, ..., beta3n;
//   ...
//   alphn1,alphn2, ..., betann]
//
//  alphij : lower triangular
//  betaij : upper triangular
//
// index[0 ... n-1] enthält die Reihen permutation
// d = +/- 1.0 Zeigt ob gerade Zahl (+1) oder ungerade (-1) von vertauschungen
//
// Rückgabe NO_ERR(0)              : okay
//          MATRIX_IS_SINGULAR(16) : singular
//==============================================================================
error_t ludcmp(Matrix a, uint32 n, uint32 *indx, double *d) {

	uint32 i,imax,j,k;
	double big,dum,sum,temp;
	double *vv;

	vv=NewVector(n);
	*d=1.0;
	for (i=0;i<n;i++) {
		big=0.0;
		for (j=0;j<n;j++)
			if ((temp=fabs(a[i][j])) > big) big=temp;
		if (big == 0.0) // singulär
            return MATRIX_IS_SINGULAR;
		vv[i]=1.0/big;
	}
	for (j=0;j<n;j++) {
		for (i=0;i<j;i++) {
			sum=a[i][j];
			for (k=0;k<i;k++) sum -= a[i][k]*a[k][j];
			a[i][j]=sum;
		}
		big=0.0;
		for (i=j;i<n;i++) {
			sum=a[i][j];
			for (k=0;k<j;k++)
				sum -= a[i][k]*a[k][j];
			a[i][j]=sum;
			if ( (dum=vv[i]*fabs(sum)) >= big) {
				big=dum;
				imax=i;
			}
		}
		if (j != imax) {
			for (k=0;k<n;k++) {
				dum=a[imax][k];
				a[imax][k]=a[j][k];
				a[j][k]=dum;
			}
			*d = -(*d);
			vv[imax]=vv[j];
		}
		indx[j]=imax;
		if (a[j][j] == 0.0) a[j][j]=DEPSILON;
		if (j != n-1) {
			dum=1.0/(a[j][j]);
			for (i=j+1;i<n;i++) a[i][j] *= dum;
		}
	}
	FreeVector(vv);

    return NO_ERR;
}

//==============================================================================
// LU-Decomposition by Gaussian elimination of a banded matrix
// with lower bandwidth ml and upper bandwidth mu
// ==================================================
// Input
// a[0 ... n-1][0 ... n-1]
// n   order orginalmatrix
// ml  lower bandwidth of a (diagnonal not counted)
// mu  upper bandwidth of a (diagnonal not counted)
//
// Output
/*     a       AN UPPER TRIANGULAR MATRIX IN BAND STORAGE AND */
/*                THE MULTIPLIERS WHICH WERE USED TO OBTAIN IT. */
/*     ip      INDEX VECTOR OF PIVOT INDICES. */
//     d = +/- 1.0 Zeigt ob gerade Zahl (+1) oder ungerade (-1) von vertauschungen
/*              USE  SOLB  TO OBTAIN SOLUTION OF LINEAR SYSTEM. */
// index[0 ... n-1] enthält die Reihen permutation
//
// Rückgabe NO_ERR(0)              : okay
//          MATRIX_IS_SINGULAR(16) : singular
/*  DETERM(A) = IP(N)*A(MD,1)*A(MD,2)*...*A(MD,N)  WITH MD=ML+MU+1. */

/*  REFERENCE.. */
/*     THIS IS A MODIFICATION OF */
/*     C. B. MOLER, ALGORITHM 423, LINEAR EQUATION SOLVER, */
/*     C.A.C.M. 15 (1972), P. 274. */
//
//==================================================================================
error_t ludcmpb(Matrix a, uint32 n, uint32 ml, uint32 mu, uint32 *indx, double *d) {

    /* Local variables */
    static uint32 i,j,k,m;
    static double t;
    static uint32 md, jk, mm, ju, md1, nm1, kp1, mdl, ijk;

    md = ml + mu + 1;
    md1 = md + 1;

    ju = 0;
    *d = 1.0;
    
    if (ml && n > 1){
    
        if (n >= mu + 2) {

            for (j = mu + 2; j <= n; ++j) {
                for (i = 1; i <= ml; ++i) 
                    a[i-1][j-1] = 0.;
            }
        }
        nm1 = n - 1;
        for (k = 1; k <= nm1; ++k) {
	        kp1 = k + 1;
	        m   = md;
	        mdl = MIN(ml,n-k) + md;
    	    for (i = md1; i <= mdl; ++i) {
	            if( fabs(a[i-1][k-1]) > fabs(a[m-1][k-1]) ) 
                    m = i;
	        
	        }
	        indx[k - 1] = m + k - md;
    	    t = a[m-1][k-1];
            if (m != md) {
	    
                *d *= -1.0;
        	    a[m-1][k-1]  = a[md-1][k-1];
    	        a[md-1][k-1] = t;
            }
    
    	    if (t == 0.)  return MATRIX_IS_SINGULAR;
	    
    	    t = 1. / t;
    	    for (i = md1; i <= mdl; ++i) 
    	        a[i-1][k-1] = -a[i-1][k-1] * t;
	    
            ju  = MIN(MAX(ju,mu+indx[k-1]),n);

    	    mm = md;
            if (ju >= kp1) {
	    
                for (j = kp1; j <= ju; ++j) {
    	            --m;
    	            --mm;
    	            t = a[m-1][j-1];
                    if (m != mm) {
	            
    	                a[m-1][j-1] = a[mm-1][j-1];
    	                a[mm-1][j-1] = t;
                    }
                    if (t != 0.) {
	            
    	                jk = j - k;
    	                for (i = md1; i <= mdl; ++i) {
    		                ijk = i - jk;
    		                a[ijk-1][j-1] = a[ijk-1][j-1] + a[i-1][k-1] * t;
	                    }

                    }                    
    	        }
            }
        }
    }
    k = n;
    if (a[md-1][n-1] == 0.)	
        return MATRIX_IS_SINGULAR;
    
    return NO_ERR;

    ;
}
/*C  MATRIX TRIANGULARIZATION BY GAUSSIAN ELIMINATION OF A HESSENBERG
C  MATRIX WITH LOWER BANDWIDTH LB
C  INPUT..
C     N = ORDER OF MATRIX A.
C     NDIM = DECLARED DIMENSION OF ARRAY  A .
C     A = MATRIX TO BE TRIANGULARIZED.
C     LB = LOWER BANDWIDTH OF A (DIAGONAL IS NOT COUNTED, LB.GE.1).
C  OUTPUT..
C     A(I,J), I.LE.J = UPPER TRIANGULAR FACTOR, U .
C     A(I,J), I.GT.J = MULTIPLIERS = LOWER TRIANGULAR FACTOR, I - L.
C     IP(K), K.LT.N = INDEX OF K-TH PIVOT ROW.
C     d = +/- 1.0 Zeigt ob gerade Zahl (+1) oder ungerade (-1) von vertauschungen
C              USE  SOLB  TO OBTAIN SOLUTION OF LINEAR SYSTEM.
C     index[0 ... n-1] enthält die Reihen permutation
C     IER = 0 IF MATRIX A IS NONSINGULAR, OR K IF FOUND TO BE
C           SINGULAR AT STAGE K.
C  USE  SOLH  TO OBTAIN SOLUTION OF LINEAR SYSTEM.
C  DETERM(A) = IP(N)*A(1,1)*A(2,2)*...*A(N,N).
C  IF IP(N)=O, A IS SINGULAR, SOL WILL DIVIDE BY ZERO.
C
C  REFERENCE..
C     THIS IS A SLIGHT MODIFICATION OF
C     C. B. MOLER, ALGORITHM 423, LINEAR EQUATION SOLVER,
C     C.A.C.M. 15 (1972), P. 274.
C-----------------------------------------------------------------------*/
error_t ludcmph(Matrix a,uint32 n, uint32 lb, uint32 *indx, double *d) {
  
    uint32 nm1,k,i,j,m,na,kp1;
    double t;

    *d = 1.0;
    if(n > 1) {
      
        nm1 = n - 1;
        for(k=1;k<=nm1;k++) {
            kp1 = k + 1;
            m   = k;
            na  = MIN(n,lb+k);
            for(i=kp1;i<=na;i++) {
                if( fabs(a[i-1][k-1]) > fabs(a[m-1][k-1]) ) 
                    m = i;
            }
            indx[k-1] = m;
            t = a[m-1][k-1];
            if( m != k ) {
                *d *= -1.;
                a[m-1][k-1] = a[k-1][k-1];
                a[k-1][k-1] = t;
            }
            if( t == 0.0) return MATRIX_IS_SINGULAR;
            t = 1.0/t;
            for(i=kp1;i<=na;i++) 
                a[i-1][k-1] = -a[i-1][k-1]*t;
            for(j=kp1;j<=n;j++) {
        
                t = a[m-1][j-1];
                a[m-1][j-1] = a[k-1][j-1];
                a[k-1][j-1] = t;
                if( t != 0.0) {
                    for(i=kp1;i<=na;i++)
                        a[i-1][j-1] += a[i-1][k-1]*t;
                }
            }
        }
    }
    k = n;
    if( a[n-1][n-1] == 0.0) 
        return MATRIX_IS_SINGULAR;

    return NO_ERR;
}
/*
C     this subroutine is a translation of the algol procedure elmhes,
C     num. math. 12, 349-368(1968) by martin and wilkinson.
C     handbook for auto. comp., vol.ii-linear algebra, 339-358(1971).
C
C     given a real general matrix, this subroutine
C     reduces a submatrix situated in rows and columns
C     low through igh to upper hessenberg form by
C     stabilized elementary similarity transformations.
C
C     on input:
C
C      nm must be set to the row dimension of two-dimensional
C        array parameters as declared in the calling program
C        dimension statement;
C
C      n is the order of the matrix;
C
C      low and igh are integers determined by the balancing
C        subroutine  balanc.      if  balanc  has not been used,
C        set low=1, igh=n;
C
C      a contains the input matrix.
C
C     on output:
C
C      a contains the hessenberg matrix.  the multipliers
C        which were used in the reduction are stored in the
C        remaining triangle under the hessenberg matrix;
C
C      int contains information on the rows and columns
C        interchanged in the reduction.
C        only elements low through igh are used.
C
C     questions and comments should be directed to b. s. garbow,
C     applied mathematics division, argonne national laboratory
C
C     ------------------------------------------------------------------
C
*/
void elmhes(uint32 n,uint32 low,uint32 igh,Matrix a,uint32 *iphes) {
    
    uint32 la,kp1,mm1,mp1,i,m,j;
    double x,y;
        
    la = igh - 1;
    kp1 = low + 1;
    if (la < kp1) return;
    if( GET_NROWS(a) < n ) return;
    
    for(m=kp1;m<=la;m++) {
        
        mm1 = m - 1;
        x   = 0.0;
        i   = m;
        
        for(j=m;j<=igh;j++) {
            
            if(fabs(a[j-1][mm1-1]) > fabs(x) ) {
                x = a[j-1][mm1-1];
                i = j;
            }
        }
        iphes[m-1] = i;
        if( i != m ) {
            //    :::::::::: interchange rows and columns of a ::::::::::
            for(j=mm1;j<=n;j++) {
                y = a[i-1][j-1];
                a[i-1][j-1] = a[m-1][j-1];
                a[m-1][j-1] = y;
            }
            
            for(j=1;j<=igh;j++) {
                y           = a[j-1][i-1];
                a[j-1][i-1] = a[j-1][m-1];
                a[j-1][m-1] = y;
            }
        }
        //    :::::::::: end interchange ::::::::::
        
        if (x != 0.0) {
            
            mp1 = m + 1;
            
            for(i=mp1;i<=igh;i++) {
                
                y = a[i-1][mm1-1];
                if (y != 0.0) {
                    y             = y / x;
                    a[i-1][mm1-1] = y;
                    
                    for(j=m;j<=n;j++) 
                        a[i-1][j-1] -= y * a[m-1][j-1];
                    
                    for(j=1;j<=igh;j++)
                        a[j-1][m-1] += y * a[j-1][i-1];
                    
                }
            }
        }
        
    }
}
